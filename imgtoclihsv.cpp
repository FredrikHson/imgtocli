#!/bin/bash
outputfile=$(mktemp -u)
cat $0 | tail -n +6 | /usr/bin/c++ -I$(dirname $0) -lIL -lILU -xc++ - -o $outputfile && $outputfile "$@"
rm $outputfile
exit 0
#include <stdio.h>
#include <stdlib.h>
#include <IL/il.h>
#include <IL/ilu.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <math.h>
#include <memory.h>

float inputpalhsv[720];
extern unsigned char inputpal[720];
unsigned char getclosestcolor(short r, short g, short b);
unsigned char getclosestcolorhsv(float h, float s, float v);

void rgbtohsv(short sr, short sg, short sb, float& h, float& s, float& v)
{
    float r = (float)sr / 255.0f;
    float g = (float)sg / 255.0f;
    float b = (float)sb / 255.0f;

    float min, max, delta;
    min = r;

    if(g < min)
    {
        min = g;
    }

    if(b < min)
    {
        min = b;
    }

    max = r;

    if(g > max)
    {
        max = g;
    }

    if(b > max)
    {
        max = b;
    }

    v = max;
    delta = max - min;

    if(max != 0)
    {
        s = delta / max;
    }
    else
    {
        s = 0;
        h = -1;
        return;
    }

    if(r == max)
    {
        h = (g - b) / delta;
    }
    else if(g == max)
    {
        h = 2 + (b - r) / delta;
    }
    else
    {
        h = 4 + (r - g) / delta;
    }

    if(h < 0)
    {
        h += 6.0;
    }

}
void hsvtorgb(short& sr, short& sg, short& sb, float h, float s, float v)
{

    int i;
    float f, p, q, t;

    if(s == 0)
    {
        sr = sg = sb = v * 255.0;
        return;
    }

    i = floor(h);
    f = h - i;
    p = v * (1 - s);
    q = v * (1 - s * f);
    t = v * (1 - s * (1 - f));

    switch(i)
    {
        case 0:
            sr = v * 255.0;
            sg = t * 255.0;
            sb = p * 255.0;
            break;

        case 1:
            sr = q * 255.0;
            sg = v * 255.0;
            sb = p * 255.0;
            break;

        case 2:
            sr = p * 255.0;
            sg = v * 255.0;
            sb = t * 255.0;
            break;

        case 3:
            sr = p * 255.0;
            sg = q * 255.0;
            sb = v * 255.0;
            break;

        case 4:
            sr = t * 255.0;
            sg = p * 255.0;
            sb = v * 255.0;
            break;

        default:
            sr = v * 255.0;
            sg = p * 255.0;
            sb = q * 255.0;
            break;
    }
}
int plotPixel(unsigned char top, unsigned char bottom, char* buffer, int* bufferoffset)
{
    return sprintf(buffer + *bufferoffset, "\33[48;5;%d;38;5;%dmâ–„", top, bottom);
}
int main(int argc, char* argv[])
{
    int w, h;
    struct winsize term;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &term);
    h = term.ws_row * 2;
    w = term.ws_col;

    for(int i = 0; i < 720; i += 3)
    {
        float h, s, v;
        rgbtohsv(inputpal[i], inputpal[i + 1], inputpal[i + 2],  h, s, v);
        inputpalhsv[i]     = h;
        inputpalhsv[i + 1] = s;
        inputpalhsv[i + 2] = v;
    }

    ilInit();
    iluInit();
    ilLoadImage(argv[1]);
    int img_w    = ilGetInteger(IL_IMAGE_WIDTH);
    int img_h    = ilGetInteger(IL_IMAGE_HEIGHT);
    int target_w = img_w;
    int target_h = img_h;

    if(img_w > w)
    {
        target_w = w;
        target_h = img_h * (float)target_w / (float)img_w;
    }

    if(target_h > h)
    {
        target_h = h;
        target_w = img_w * (float)target_h / (float)img_h;
    }

    iluImageParameter(ILU_FILTER, ILU_SCALE_MITCHELL);
    iluScale(target_w, target_h, 1);
    unsigned char* data = new unsigned char[target_w * target_h * 3];
    ilCopyPixels(0, 0, 0, target_w, target_h, 1, IL_RGB, IL_UNSIGNED_BYTE, data);
    int bytesused  = 0;
    int buffersize = (target_h / 2 * target_w * 23) + (target_h / 2 * 5) + 1;
    char* buffer   = new char[buffersize];
    memset(buffer, 0, buffersize);
    int bufferoffset = 0;

    float* datadither = new float [ target_w * target_h * 3];
    unsigned char* datadither8bit = new unsigned char [ target_w * target_h ];

    for(int i = 0; i < (target_w * target_h * 3); i += 3)
    {

        float h, s, v;
        rgbtohsv(data[i], data[i + 1], data[i + 2], h, s, v);
        datadither[i] = h;
        datadither[i + 1] = s;
        datadither[i + 2] = v;

    }

    for(int j = 0; j < target_h; j++)
    {
        for(int i = 0; i < target_w; i++)
        {
#define GETOFFSET(x,y,w) ((x) * 3 + (y) * w * 3)
            unsigned int offset = GETOFFSET(i, j, target_w);
            float h = datadither[offset];
            float s = datadither[offset + 1];
            float v = datadither[offset + 2];
            unsigned char closestcolor = getclosestcolorhsv(h, s, v);
            float new_v = inputpalhsv[(closestcolor - 16) * 3 + 2];
            float vquanterror = v - new_v;

            if((i + 1) < target_w)
            {
                unsigned int currentpixel = GETOFFSET(i + 1, j, target_w);
                datadither[currentpixel + 2] += vquanterror * (7.0 / 16.0);
            }

            if((i - 1) >= 0 && (j + 1) < target_h)
            {
                unsigned int currentpixel = GETOFFSET(i - 1, j + 1, target_w);
                datadither[currentpixel + 2] += vquanterror * (3.0 / 16.0);
            }

            if((j + 1) < target_h)
            {
                unsigned int currentpixel = GETOFFSET(i , j + 1, target_w);
                datadither[currentpixel + 2] += vquanterror * (5.0 / 16.0);
            }

            if((i + 1) < target_w && (j + 1) < target_h)
            {
                unsigned int currentpixel = GETOFFSET(i + 1, j + 1, target_w);
                datadither[currentpixel + 2] += vquanterror * (1.0 / 16.0);
            }

            datadither8bit[i + j * target_w] = closestcolor;
        }

    }

    for(int j = 0; j < target_h / 2; j++)
    {
        for(int i = 0; i < target_w; i++)
        {
            unsigned int offset = i  + j * 2 * target_w  ;
            unsigned char topcolor = datadither8bit[offset];
            unsigned char bottomcolor =  datadither8bit[offset + target_w];

            bytesused = plotPixel(topcolor, bottomcolor, buffer, &bufferoffset);
            bufferoffset += bytesused;

        }

        bytesused = sprintf(buffer + bufferoffset, "\33[0m\n");
        bufferoffset += bytesused;

    }

    fwrite(buffer, bufferoffset, 1, stdout);
    fprintf(stdout, "\33[0m");
    fflush(stdout);
    delete [] data;
    delete [] datadither;
    delete [] datadither8bit;
    delete [] buffer;
    return 0;
}

unsigned char inputpal[720] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x87,
    0x00, 0x00, 0xaf, 0x00, 0x00, 0xd7, 0x00, 0x00, 0xff,
    0x00, 0x5f, 0x00, 0x00, 0x5f, 0x5f, 0x00, 0x5f, 0x87,
    0x00, 0x5f, 0xaf, 0x00, 0x5f, 0xd7, 0x00, 0x5f, 0xff,
    0x00, 0x87, 0x00, 0x00, 0x87, 0x5f, 0x00, 0x87, 0x87,
    0x00, 0x87, 0xaf, 0x00, 0x87, 0xd7, 0x00, 0x87, 0xff,
    0x00, 0xaf, 0x00, 0x00, 0xaf, 0x5f, 0x00, 0xaf, 0x87,
    0x00, 0xaf, 0xaf, 0x00, 0xaf, 0xd7, 0x00, 0xaf, 0xff,
    0x00, 0xd7, 0x00, 0x00, 0xd7, 0x5f, 0x00, 0xd7, 0x87,
    0x00, 0xd7, 0xaf, 0x00, 0xd7, 0xd7, 0x00, 0xd7, 0xff,
    0x00, 0xff, 0x00, 0x00, 0xff, 0x5f, 0x00, 0xff, 0x87,
    0x00, 0xff, 0xaf, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,
    0x5f, 0x00, 0x00, 0x5f, 0x00, 0x5f, 0x5f, 0x00, 0x87,
    0x5f, 0x00, 0xaf, 0x5f, 0x00, 0xd7, 0x5f, 0x00, 0xff,
    0x5f, 0x5f, 0x00, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x87,
    0x5f, 0x5f, 0xaf, 0x5f, 0x5f, 0xd7, 0x5f, 0x5f, 0xff,
    0x5f, 0x87, 0x00, 0x5f, 0x87, 0x5f, 0x5f, 0x87, 0x87,
    0x5f, 0x87, 0xaf, 0x5f, 0x87, 0xd7, 0x5f, 0x87, 0xff,
    0x5f, 0xaf, 0x00, 0x5f, 0xaf, 0x5f, 0x5f, 0xaf, 0x87,
    0x5f, 0xaf, 0xaf, 0x5f, 0xaf, 0xd7, 0x5f, 0xaf, 0xff,
    0x5f, 0xd7, 0x00, 0x5f, 0xd7, 0x5f, 0x5f, 0xd7, 0x87,
    0x5f, 0xd7, 0xaf, 0x5f, 0xd7, 0xd7, 0x5f, 0xd7, 0xff,
    0x5f, 0xff, 0x00, 0x5f, 0xff, 0x5f, 0x5f, 0xff, 0x87,
    0x5f, 0xff, 0xaf, 0x5f, 0xff, 0xd7, 0x5f, 0xff, 0xff,
    0x87, 0x00, 0x00, 0x87, 0x00, 0x5f, 0x87, 0x00, 0x87,
    0x87, 0x00, 0xaf, 0x87, 0x00, 0xd7, 0x87, 0x00, 0xff,
    0x87, 0x5f, 0x00, 0x87, 0x5f, 0x5f, 0x87, 0x5f, 0x87,
    0x87, 0x5f, 0xaf, 0x87, 0x5f, 0xd7, 0x87, 0x5f, 0xff,
    0x87, 0x87, 0x00, 0x87, 0x87, 0x5f, 0x87, 0x87, 0x87,
    0x87, 0x87, 0xaf, 0x87, 0x87, 0xd7, 0x87, 0x87, 0xff,
    0x87, 0xaf, 0x00, 0x87, 0xaf, 0x5f, 0x87, 0xaf, 0x87,
    0x87, 0xaf, 0xaf, 0x87, 0xaf, 0xd7, 0x87, 0xaf, 0xff,
    0x87, 0xd7, 0x00, 0x87, 0xd7, 0x5f, 0x87, 0xd7, 0x87,
    0x87, 0xd7, 0xaf, 0x87, 0xd7, 0xd7, 0x87, 0xd7, 0xff,
    0x87, 0xff, 0x00, 0x87, 0xff, 0x5f, 0x87, 0xff, 0x87,
    0x87, 0xff, 0xaf, 0x87, 0xff, 0xd7, 0x87, 0xff, 0xff,
    0xaf, 0x00, 0x00, 0xaf, 0x00, 0x5f, 0xaf, 0x00, 0x87,
    0xaf, 0x00, 0xaf, 0xaf, 0x00, 0xd7, 0xaf, 0x00, 0xff,
    0xaf, 0x5f, 0x00, 0xaf, 0x5f, 0x5f, 0xaf, 0x5f, 0x87,
    0xaf, 0x5f, 0xaf, 0xaf, 0x5f, 0xd7, 0xaf, 0x5f, 0xff,
    0xaf, 0x87, 0x00, 0xaf, 0x87, 0x5f, 0xaf, 0x87, 0x87,
    0xaf, 0x87, 0xaf, 0xaf, 0x87, 0xd7, 0xaf, 0x87, 0xff,
    0xaf, 0xaf, 0x00, 0xaf, 0xaf, 0x5f, 0xaf, 0xaf, 0x87,
    0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xd7, 0xaf, 0xaf, 0xff,
    0xaf, 0xd7, 0x00, 0xaf, 0xd7, 0x5f, 0xaf, 0xd7, 0x87,
    0xaf, 0xd7, 0xaf, 0xaf, 0xd7, 0xd7, 0xaf, 0xd7, 0xff,
    0xaf, 0xff, 0x00, 0xaf, 0xff, 0x5f, 0xaf, 0xff, 0x87,
    0xaf, 0xff, 0xaf, 0xaf, 0xff, 0xd7, 0xaf, 0xff, 0xff,
    0xd7, 0x00, 0x00, 0xd7, 0x00, 0x5f, 0xd7, 0x00, 0x87,
    0xd7, 0x00, 0xaf, 0xd7, 0x00, 0xd7, 0xd7, 0x00, 0xff,
    0xd7, 0x5f, 0x00, 0xd7, 0x5f, 0x5f, 0xd7, 0x5f, 0x87,
    0xd7, 0x5f, 0xaf, 0xd7, 0x5f, 0xd7, 0xd7, 0x5f, 0xff,
    0xd7, 0x87, 0x00, 0xd7, 0x87, 0x5f, 0xd7, 0x87, 0x87,
    0xd7, 0x87, 0xaf, 0xd7, 0x87, 0xd7, 0xd7, 0x87, 0xff,
    0xd7, 0xaf, 0x00, 0xd7, 0xaf, 0x5f, 0xd7, 0xaf, 0x87,
    0xd7, 0xaf, 0xaf, 0xd7, 0xaf, 0xd7, 0xd7, 0xaf, 0xff,
    0xd7, 0xd7, 0x00, 0xd7, 0xd7, 0x5f, 0xd7, 0xd7, 0x87,
    0xd7, 0xd7, 0xaf, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xff,
    0xd7, 0xff, 0x00, 0xd7, 0xff, 0x5f, 0xd7, 0xff, 0x87,
    0xd7, 0xff, 0xaf, 0xd7, 0xff, 0xd7, 0xd7, 0xff, 0xff,
    0xff, 0x00, 0x00, 0xff, 0x00, 0x5f, 0xff, 0x00, 0x87,
    0xff, 0x00, 0xaf, 0xff, 0x00, 0xd7, 0xff, 0x00, 0xff,
    0xff, 0x5f, 0x00, 0xff, 0x5f, 0x5f, 0xff, 0x5f, 0x87,
    0xff, 0x5f, 0xaf, 0xff, 0x5f, 0xd7, 0xff, 0x5f, 0xff,
    0xff, 0x87, 0x00, 0xff, 0x87, 0x5f, 0xff, 0x87, 0x87,
    0xff, 0x87, 0xaf, 0xff, 0x87, 0xd7, 0xff, 0x87, 0xff,
    0xff, 0xaf, 0x00, 0xff, 0xaf, 0x5f, 0xff, 0xaf, 0x87,
    0xff, 0xaf, 0xaf, 0xff, 0xaf, 0xd7, 0xff, 0xaf, 0xff,
    0xff, 0xd7, 0x00, 0xff, 0xd7, 0x5f, 0xff, 0xd7, 0x87,
    0xff, 0xd7, 0xaf, 0xff, 0xd7, 0xd7, 0xff, 0xd7, 0xff,
    0xff, 0xff, 0x00, 0xff, 0xff, 0x5f, 0xff, 0xff, 0x87,
    0xff, 0xff, 0xaf, 0xff, 0xff, 0xd7, 0xff, 0xff, 0xff,
    0x08, 0x08, 0x08, 0x12, 0x12, 0x12, 0x1c, 0x1c, 0x1c,
    0x26, 0x26, 0x26, 0x30, 0x30, 0x30, 0x3a, 0x3a, 0x3a,
    0x44, 0x44, 0x44, 0x4e, 0x4e, 0x4e, 0x58, 0x58, 0x58,
    0x60, 0x60, 0x60, 0x66, 0x66, 0x66, 0x76, 0x76, 0x76,
    0x80, 0x80, 0x80, 0x8a, 0x8a, 0x8a, 0x94, 0x94, 0x94,
    0x9e, 0x9e, 0x9e, 0xa8, 0xa8, 0xa8, 0xb2, 0xb2, 0xb2,
    0xbc, 0xbc, 0xbc, 0xc6, 0xc6, 0xc6, 0xd0, 0xd0, 0xd0,
    0xda, 0xda, 0xda, 0xe4, 0xe4, 0xe4, 0xee, 0xee, 0xee
};

unsigned char getclosestcolor(short r, short g, short b)
{
    unsigned char closest = 0;
    float closestdist = 10000000.0f;

    for(unsigned short i = 0; i < 239; i++)
    {
        short rdist = r - inputpal[i * 3];
        short gdist = g - inputpal[i * 3 + 1];
        short bdist = b - inputpal[i * 3 + 2];
        float dist  = rdist * rdist + gdist * gdist + bdist * bdist;

        if(dist < closestdist)
        {
            closestdist = dist;
            closest = i;
        }
    }

    return closest + 16;
}
unsigned char getclosestcolorhsv(float h, float s, float v)
{
    unsigned char closest = 0;
    float closestdist = 10000000.0f;
    short r;
    short g;
    short b;

    hsvtorgb(r, g, b, h, s, v);

    for(unsigned short i = 0; i < 239; i++)
    {
        short rdist = r - inputpal[i * 3];
        short gdist = g - inputpal[i * 3 + 1];
        short bdist = b - inputpal[i * 3 + 2];
        float dist  = rdist * rdist + gdist * gdist + bdist * bdist;

        if(dist < closestdist)
        {
            closestdist = dist;
            closest = i;
        }
    }

    return closest + 16;
}
